### 学习笔记

#### 1、什么是闭包
闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值，例如：
```
fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
```
可以看到 sum 非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。



#### 2、闭包的作用, 解决什么问题  

闭包可以捕获调用者所在作用域中的值, 才是闭包最大的价值, 不是为了匿名.  
可以简化程序逻辑代码, 函数内部的逻辑实现依赖外部变量且外部变量在运行时才能确定值, 可以通过闭包来实现, [代码验证]  


#### 3、使用闭包有什么副作用或代价  
闭包在捕获调用者所在作用域中的值后需要保存起来, 但如果是普通函数的参数不需要额外的内存消耗, 会多占用一点内存是使用闭包的副作用.  


#### 4、结构体中使用闭包  

如下结构体声明中, Fn(u32) -> u32 就是T的类型(实现了Fn特征的类型), 一个返回类型是u32且有一个参数类型为u32的闭包函数.
```
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```
[代码验证]

#### 5、Fn特征 , Fn特征与闭包如何结合使用  
闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的 Fn 特征也有三种：
(1)、FnOnce 特征，该类型的闭包会拿走被捕获变量的所有权。Once 顾名思义，说明该闭包只能运行一次.
(2)、FnMut 特征, 它以可变借用的方式捕获了环境中的值，因此可以修改该值.
(3)、Fn 特征，它以不可变借用的方式捕获环境中的值.
[代码验证]


#### 6、闭包作为函数返回值  

如下代码编译报错, 是因为每一个闭包的返回类型都是不一样的, 即使签名完全一样.
```
fn factory(x:i32) -> impl Fn(i32) -> i32 {

    let num = 5;

    if x > 1{
        move |x| x + num
    } else {
        move |x| x - num
    }
}
```
可以用特征对象来实现:
```
fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```

